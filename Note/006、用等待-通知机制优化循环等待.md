### 引子

```java
由上一章我们已经知道，在"破坏占有且等待条件"的时候，如果转出账本和转入账本不满足同时在文件架上这个条件，就用死循环方式来循环等待。核心代码如下：
// 一次性申请转出账户和转入账户，直到成功
while(!actr.apply(this, target));

如果apply()操作耗时非常短，且并发冲突量不大时，适用此方案。
如果apply()操作耗时长，或并发冲突量大的时候，循环等待这种方案就不适用了。
    
其实这种场景下，最好的方案应该时：如果线程要求的条件(转出账本和转入账本同在文件架上)不满足，则线程阻塞自己，进入等待状态；当线程要求的条件满足后，通知等待的线程重新执行。其中，使用线程阻塞的方式就能避免循环等待消耗CPU的问题。
```

#### 完美的就医流程--等待-->通知机制

```java
在介绍Java语言如何支持等待-通知机制之前，我们先看一个现实世界里面的就医流程，因为它有着完善的等待-通知机制，所以对比就医流程，我们就能更好地理解和应用并发编程中的等待-通知机制。

就医流程基本上是这样的：
    1、患者先去挂号，然后到就诊门口分诊，等待叫号。
    2、当叫到自己的号时，患者就可以找大夫就诊了；
    3、就诊过程中，大夫可能会让患者去做检查，同时叫下一位患者；
    4、当患者做完检查后，拿检测报告重新分诊，等待叫号；
    5、当大夫再次叫到自己的号时，患者再去找大夫就诊。
```

下面我们来梳理下就医流程中的一些细节

```java
1、患者到就诊门口分诊，类似于线程要去获取互斥锁;当患者被叫道时，类似线程已经获取到锁了。
2、大夫让患者去做检查(缺乏检测报告不能诊断病因)，类似于线程要求的条件没有满足。
3、患者去做检查，类似于线程进入等待状态；然后大夫叫下一个患者，这个步骤我们在前面的等待-通知机制中忽视了，这个步骤对应到程序里，本质时线程释放持有的锁。(wait方法会释放持有的锁)
4、患者做完检查，类似于线程要求的条件已经满足，患者拿检测报告重新分诊，类似于线程需要重新获取互斥锁，这个步骤我们在前面的等待-通知机制中被忽视了。(wait被唤醒后会再次获取之前持有的锁)
    
综合一下，就能得出一个完整的等待-通知机制:线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程，重新获取互斥锁。
```

